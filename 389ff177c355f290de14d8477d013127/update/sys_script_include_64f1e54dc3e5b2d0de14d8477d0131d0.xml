<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_itx_codesearch.Utilities</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>Utilities</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/* global Set */
/* global gs, sn_scoped_cache */
/* global Class, GlideRecord, GlideTableHierarchy, GlideScriptedExtensionPoint */
/* eslint no-undef: "error" */
var Utilities = Class.create();
Utilities.prototype = {
	initialize: function () {
		this.ext = new GlideScriptedExtensionPoint().getExtensions('CodeSearchExt')[0];
		this.ext.initialize();

		this.use_cache = gs.getProperty('x_itx_codesearch.use_cache') == 'true';
		if (this.use_cache) {
			// automatic cache clear when script is updated and the data structure changed
			this.cache_version = '2';
			this._checkCache('table_columns');
		}
	},

	_checkCache: function (cache) {
		if (sn_scoped_cache.ScopedCacheManager.get(cache, 'cache_version') != this.cache_version) {
			sn_scoped_cache.ScopedCacheManager.flushScopedCache(cache);
			sn_scoped_cache.ScopedCacheManager.put(cache, 'cache_version', this.cache_version);
			gs.info(`clearing cache ${cache} - upgrading to cache version ${this.cache_version}`);
		}
	},

	/**
	 * @param {string} url
	 * @returns {string}
	 */
	createTinyURL: function (url) {
		return this.ext.createTinyURL(url);
	},

	/**
	 * Transform "<target>.<field><operator><value>" to "<field><operator><value>"
	 * while forwarding sys_id and sys_scope conditions.
	 * 
	 * e.g. "flow.descriptionCONTAINShello^flow.annotationCONTAINSworld^sys_scope=<scope>^sys_id=<sys_id>" to
	 * "descriptionCONTAINShello^annotationCONTAINSworld^sys_scope=<scope>^sys_id=<sys_id>"
	 * 
	 * @param {string} target
	 * @param {string} query
	 * @returns {string}
	 */
	transformRemoteTableQuery: function (target, query) {
		const targetMatches = target + '=';
		const targetDotWalk = target + '.';
		return query.split(/(?<!\^)\^EQ/).map(eq => {
			return eq.split(/(?<!\^)\^NQ/).map(nq => {
				return nq.split(/(?<!\^)\^OR/).map(or => {
					return or.split(/(?<!\^)\^/).map(and => {
						if (and.startsWith(targetMatches)) return and.replace(targetMatches, 'sys_id=');
						else if (and.startsWith(targetDotWalk)) return and.replace(targetDotWalk, '');
						else if (and.startsWith('sys_id')) return and;
						else if (and.startsWith('sys_scope')) return and;

						// ignore all other (only data?) conditions parts
						// currently (due to caching), there is no need
						// to implement this
					}).filter(q => !!q).join('^');
				}).filter(q => !!q).join('^OR');
			}).filter(q => !!q).join('^NQ');
		}).filter(q => !!q).join('^EQ');
	},

	/**
	 * @param {string} table
	 * @returns {{name: string, type: string, max_length: number}[]}
	 */
	getTableFields: function (table) {
		const cache = sn_scoped_cache.ScopedCacheManager.get('table_columns', table);
		if (cache) {
			return JSON.parse(cache);
		}

		const dictionaryGr = new GlideRecord('sys_dictionary');
		dictionaryGr.addQuery('name', 'IN', new GlideTableHierarchy(table).getTables());
		dictionaryGr.addQuery('internal_type.scalar_type', 'IN', ['GUID', 'string']);
		dictionaryGr.addNotNullQuery('element');
		dictionaryGr.query();

		const fields = [{
			name: 'sys_id',
			type: 'GUID',
			max_length: 32
		}];
		while (dictionaryGr.next()) {
			const name = dictionaryGr.getValue('element');
			if (name.startsWith('sys_')) continue;

			fields.push({
				name: name,
				table: dictionaryGr.getValue('name'),
				type: dictionaryGr.getValue('internal_type'),
				max_length: +dictionaryGr.max_length.toString()
			});
		}

		sn_scoped_cache.ScopedCacheManager.put('table_columns', table, JSON.stringify(fields));
		return fields;
	},

	getTableTree: function (table) {
		const children = {};

		for (const child of new GlideTableHierarchy(table).getTableExtensions()) {
			children[child] = this.getTableTree(child);
		}
		
		return children;
	},

	/**
	 * @param {GlideRecordGenerated} anyGr
	 * @returns {{ name: string, value: string }[]}
	 */
	toJSON: function (anyGr) {
		const fields = [];
		anyGr.getElements().forEach((element) => {
			const ge = element.getED();
			const name = ge.getName();
			if (name.startsWith('sys_') && name != 'sys_id') return;

			const type = ge.getInternalType();
			// gziped fields typically have this length (and usually there is only a single such field)
			if (type == 'string') {
				const value = element.toString();
				if (!value) return;
				
				fields.push({
					name: name,
					value: ge.getLength() == 16777215 && value.startsWith('H4sIAAAAAAAA')
						? this.deflateFields(value)
						: value
				});
			} else if (type == 'glide_var' || type == 'variables') {
				fields.push({
					name: name,
					value: this.glideVarFields(element)
				});
			} else {
				const value = element.toString();
				const display = element.getDisplayValue();
				const field = {
					name: name,
					value: value
				};

				if (display != value) {
					field.display = display;
				}

				fields.push(field);
			}
		});

		return fields.filter(field => field.value?.length);
	},

	/**
	 * @param {string} value
	 * @returns {{ name: string, value: string }[]}
	 */
	deflateFields: function (value) {
		if (value) {
			const fields = JSON.parse(this.ext.inflate(value));
			if (Array.isArray(fields)) {
				return fields
					.filter(field => field.value || (field.scriptActive && field.script))
					.map(field => {
						return {
							name: field.name,
							value: field.value,
							scriptActive: field.scriptActive,
							script: field.script
						};
					});
			}

			// simple Object.<string, string>
			return Object.entries(fields)
				.filter(([name, value]) => value)
				.map(([name, value]) => { return { name, value }; });
		}

		return [];
	},

	/**
	 * @param {GlideElementGenerated} glideElement
	 * @returns {{ name: string, value: string }[]}
	 */
	glideVarFields: function (glideElement) {
		const values = [];
		for (const name in glideElement) {
			if (name == 'sys_id' || name == 'sys_meta') continue;
			const value = String(glideElement[name]);
			if (!value) continue;

			const display = glideElement[name].getDisplayValue();
			const field = {
				name: name,
				value: value
			};

			if (display != value) {
				field.display = display;
			}

			values.push(field);
		}

		return values;
	},

	type: 'Utilities'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus@intrux.ch</sys_created_by>
        <sys_created_on>2025-11-29 18:32:17</sys_created_on>
        <sys_id>64f1e54dc3e5b2d0de14d8477d0131d0</sys_id>
        <sys_mod_count>38</sys_mod_count>
        <sys_name>Utilities</sys_name>
        <sys_package display_value="Intrux Code Search" source="x_itx_codesearch">389ff177c355f290de14d8477d013127</sys_package>
        <sys_policy/>
        <sys_scope display_value="Intrux Code Search">389ff177c355f290de14d8477d013127</sys_scope>
        <sys_update_name>sys_script_include_64f1e54dc3e5b2d0de14d8477d0131d0</sys_update_name>
        <sys_updated_by>markus.kraus@intrux.ch</sys_updated_by>
        <sys_updated_on>2025-12-28 21:54:01</sys_updated_on>
    </sys_script_include>
</record_update>
