<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_itx_codesearch.CodeSearchHandlerAny</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Implements extension point x_itx_codesearch.CodeSearchHandler&#13;
&#13;
The OOTB code search expects the sys_class_name field to be present on the searched table. If this is not the case, the table will not be searched at all.&#13;
Adding the 'CodeSearch Proxy' table will pick up all the tables which do not have this field which will be covered by this handler.</description>
        <mobile_callable>false</mobile_callable>
        <name>CodeSearchHandlerAny</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/* global Set */
/* global gs, x_itx_codesearch */
/* global Class, GlideRecord, GlideAggregate, GlideTableHierarchy, GlideScopedEvaluator */
/* eslint no-undef: "error" */
var CodeSearchHandlerAny = Class.create();
CodeSearchHandlerAny.prototype = {
	initialize: function () {
		this.util = new x_itx_codesearch.Utilities();

		const scriptGr = new GlideRecord('clone_cleanup_script');
		scriptGr.addQuery('sys_scope', 'global');
		scriptGr.setLimit(1);
		scriptGr.query();
		if (scriptGr.next()) {
			this.scriptGr = scriptGr;
		} else {
			throw new Error('No infuseable script found');
		}
	},

	/**
	 * the proxy search handler can handle all non-configuration tables
	 * 
	 * @static
	 * @param {object} [context]
	 * @param {string} [context.scope]
	 * @param {string} [context.table]
	 * @param {string} [context.group]
	 * @returns {string[]}
	 */
	getHandledTables: function (context) {
		if (context?.table) {
			const info = new GlideTableHierarchy(context.table);
			if (gs.tableExists(context.table) && info.getRoot() != 'sys_metadata') {
				if (context.extensions) {
					return info.getAllExtensions();
				}
				
				return [context.table];
			}

			return [];
		}

		const tables = [];
		if (context?.group) {
			// Note: The scope parameter is ignored because this parameter is only applicable for
			// metadata files - which are handled by CodeSearchHandlerMetadata
			const tableGr = new GlideRecord('sn_codesearch_table');
			tableGr.addQuery('search_group', context.group);
			tableGr.query();
			while (tableGr.next()) {
				const table = tableGr.table.toString();
				if (!hasClassName(table)) {
					tables.push(table);
				}
			}
		}
		
		return tables;

		function hasClassName(table) {
			const dictGr = new GlideRecord('sys_dictionary');
			dictGr.addQuery('element', 'sys_class_name');
			// theoretically it should be enough to look for sys_class_name on the base table
			dictGr.addQuery('name', 'IN', new GlideTableHierarchy(table).getTables());
			dictGr.setLimit(1);
			dictGr.query();
			return dictGr.hasNext();
		}
	},

	/**
	 * returning true always as this handler can search all tables (extension 
	 * point order will ensure this is the last to be called)
	 * 
	 * @param {string} table
	 * @return {boolean}
	 */
	handlesTable: function (table) {
		return true;
	},

	/**
	 * get the SysIDs of records that match the record
	 * 
	 * @param {string} table
	 * @param {string} term
	 * @param {object} [options]
 	 * @param {number} [options.limit]
	 * @param {boolean} [options.children]
	 * @returns {string[]}
	 */
	search: function (table, term, options) {
		const fields = [];
		const glideVarFields = [];
		const variableFields = [];
		const journalFields = [];
		this.util.getTableFields(table).forEach(field => {
			if (field.type == 'glide_var') {
				glideVarFields.push(field);
			} else if (field.type == 'variables') {
				variableFields.push(field);
			} else if (!field.name.startsWith('sys_')) {
				if (field.type == 'journal' || field.type == 'journal_input') {
					journalFields.push(field);
				} else if (!field.type.startsWith('journal')) {
					fields.push(field.name);
				}

				// sys_* and journal_list fields are ignored
			}
		});

		this.scriptGr.script = `(function (table, fields, term, limit) {
			var anyGr = new GlideRecord(table);
			var cond = anyGr.addQuery('sys_id', term);
			fields.forEach(function (field) {
				cond.addOrCondition(field, 'CONTAINS', term);
			});
			
			if (limit) {
				anyGr.setLimit(limit);
			}
			
			anyGr.query();

			var hits = [];
			while (anyGr.next()) {
				hits.push(anyGr.getUniqueValue());
			}

			return hits;
		})(table, fields, term, limit);`;

		const gse = new GlideScopedEvaluator();
		gse.putVariable('fields', fields);
		const hits = new Set(gse.evaluateScript(this.scriptGr, 'script', {
			table: table,
			term: term,
			limit: options?.limit || 0
		}));

		// Note: As scope is only relevant for metadata searches, there is scope handling
		// inside this function because the metadata handler should have picked this up
		// already (via extension point order)
		if (glideVarFields.length) {
			const variableGr = new GlideRecord('sys_variable_value');
			variableGr.addQuery('document', table);
			variableGr.addNotNullQuery('document_key');
			variableGr.addQuery('value', 'CONTAINS', term);
			variableGr.query();
			while (variableGr.next()) {
				hits.add(variableGr.getValue('document_key'));
			}
		}

		if (variableFields.length) {
			// the variables dictionary entry is active=false
			// and because the tables the variable values are actually
			// stored in seem to differ for each table using it:
			// sc_req_item, sc_cart_item -> sc_item_option_mtom
			// incidents, change_request, ... -> question_answer
			const hierarchy = new GlideTableHierarchy(table).getTables();
			if (hierarchy.includes('sc_req_item') || hierarchy.includes('sc_cart_item')) {
				const optionGa = new GlideAggregate('sc_item_option_mtom');
				optionGa.addQuery('sc_item_option.value', 'CONTAINS', term);
				optionGa.addNotNullQuery('request_item');
				optionGa.groupBy('request_item');
				optionGa.query();
				while (optionGa.next()) {
					hits.add(optionGa.getValue('request_item'));
				}

				const mrvsAnswerGa = new GlideAggregate('sc_multi_row_question_answer');
				mrvsAnswerGa.addQuery('value', 'CONTAINS', term);
				mrvsAnswerGa.addQuery('parent_table_name', table);
				mrvsAnswerGa.addNotNullQuery('parent_id');
				mrvsAnswerGa.groupBy('parent_id');
				mrvsAnswerGa.query();
				while (mrvsAnswerGa.next()) {
					hits.add(mrvsAnswerGa.getValue('parent_id'));
				}
			} else {			
				const answerGa = new GlideAggregate('question_answer');
				answerGa.addQuery('table_name', table);
				answerGa.addQuery('value', 'CONTAINS', term);
				answerGa.groupBy('table_sys_id');
				answerGa.query();
				while (answerGa.next()) {
					hits.add(answerGa.getValue('table_sys_id'));
				}
			}
		}

		if (journalFields.length) {
			const journalFieldGa = new GlideAggregate('sys_journal_field');
			journalFieldGa.addQuery('name', table);
			journalFieldGa.addQuery('value', 'CONTAINS', term);
			journalFieldGa.groupBy('element_id');
			journalFieldGa.query();
			while (journalFieldGa.next()) {
				hits.add(journalFieldGa.getValue('element_id'));
			}
		}

		return [...hits];
	},

	/**
	 * Convert the given record to JSON data structure suitable to be used in a code search.
	 * 
	 * @param {GlideRecordGenerated} anyGr
	 * @param {object} options
	 * @returns {JSON}
	 */
	toJSON: function (anyGr, options) {
		return {
			sys_class_name: anyGr.getRecordClassName(),
			sys_id: anyGr.getUniqueValue(),
			fields: this.util.toJSON(anyGr, options)
		};
	},

	/**
	 * @param {string} table
	 * @param {GlideElement | GlideDateTime | string} since
	 * @param {object} context
	 * @param {string} [context.scope]
	 * @returns {boolean}
	 */
	updatedSince: function (table, since, context) {
		this.scriptGr.script = `(function (table, since, context) {
			var anyGr = new GlideRecord(table);
			if (context.scope && anyGr.isValidField('sys_scope')) anyGr.addQuery('sys_scope', context.scope);
			if (anyGr.isValidField('sys_updated_on')) anyGr.addQuery('sys_updated_on', '>', since);
			else if (anyGr.isValidField('sys_created_on')) anyGr.addQuery('sys_created_on', '>', since);
			else anyGr.addQuery('sys_id', 'x');
			anyGr.setLimit(1);
			anyGr.query();
			return anyGr.hasNext();
		})(table, since, context);`;
		const gse = new GlideScopedEvaluator();
		gse.putVariable('since', since);
		gse.putVariable('context', context);
		return gse.evaluateScript(this.scriptGr, 'script', {
			table
		});
	},

	/**
	 * @param {string} table
	 * @param {string[]} sysIDs
	 * @returns {GlideRecordGenerated}
	 */
	lookup: function (table, sysIDs) {
		this.scriptGr.script = `(function (table, sysIDs) {
			var anyGr = new GlideRecord(table);
			anyGr.addQuery('sys_id', 'IN', sysIDs);
			anyGr.setLimit(sysIDs.length);
			anyGr.query();
			return anyGr;
		})(table, sysIDs);`;
		const gse = new GlideScopedEvaluator();
		gse.putVariable('sysIDs', sysIDs);
		return gse.evaluateScript(this.scriptGr, 'script', {
			table: table
		});
	},

	type: 'CodeSearchHandlerAny'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus@intrux.ch</sys_created_by>
        <sys_created_on>2025-12-05 18:00:53</sys_created_on>
        <sys_id>8e33344bc3edba14de14d8477d013145</sys_id>
        <sys_mod_count>69</sys_mod_count>
        <sys_name>CodeSearchHandlerAny</sys_name>
        <sys_package display_value="Intrux Code Search" source="x_itx_codesearch">389ff177c355f290de14d8477d013127</sys_package>
        <sys_policy/>
        <sys_scope display_value="Intrux Code Search">389ff177c355f290de14d8477d013127</sys_scope>
        <sys_update_name>sys_script_include_8e33344bc3edba14de14d8477d013145</sys_update_name>
        <sys_updated_by>markus.kraus@intrux.ch</sys_updated_by>
        <sys_updated_on>2026-01-01 08:29:42</sys_updated_on>
    </sys_script_include>
</record_update>
