<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_itx_codesearch.CodeSearchWorker</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>The CodeSearchWorker reuses previous searches on two levels:&#13;
1.) Table Search (CodeSearchWorker::start) &#13;
-&gt; If a table hasn't been changed since the last search, don't start a new worker and simply display the last results&#13;
2.) Group / Table+Extensions (CodeSearchWorker::_search)&#13;
-&gt; If a table has searched, then check for each extension (respectively each table of a group) individually for updated since last search and reuse the search term if feasable.&#13;
-&gt; Note: Checking each sys_metadata individually for updates is actually faster than a GlideAggregate with MAX aggregate on 'sys_updated_on'</description>
        <mobile_callable>false</mobile_callable>
        <name>CodeSearchWorker</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/* global global, gs, x_itx_codesearch */
/* global Set */
/* global Class, GlideRecord, GlideTableHierarchy, GlideScriptedHierarchicalWorker, GlideExecutionTracker */
/* eslint no-undef: "error" */
var CodeSearchWorker = Class.create();
CodeSearchWorker.getLastSearch = function (term, context) {
	const STATE_SUCCESSFULL = 2;
	const executionGr = new GlideRecord('sys_execution_tracker');
	executionGr.addQuery('name', 'Intrux Code Search: ' + term);
	executionGr.addQuery('state', STATE_SUCCESSFULL);
	if (context.scope) {
		executionGr.addQuery('source_table', 'sys_scope');
		executionGr.addQuery('source', context.scope);
	}

	executionGr.orderByDesc('sys_updated_on');
	executionGr.setLimit(1);
	executionGr.query();
	executionGr.next();
	return executionGr;
};
CodeSearchWorker.start = function (term, context) {
	if (context.table) {
		// if the table hasn't changed since the most recent search
		// the worker can be used instead
		const lastSearchGr = CodeSearchWorker.getLastSearch(term, context);
		if (lastSearchGr.isValidRecord()) {
			const api = new x_itx_codesearch.CodeSearchAPI();
			if (!api.updatedSince(context.table, lastSearchGr.sys_created_on, context)) {
				return lastSearchGr.getUniqueValue();
			}
		}
	}

	const worker = new GlideScriptedHierarchicalWorker();
	worker.setProgressName('Intrux Code Search: ' + term);
	worker.setScriptIncludeName('x_itx_codesearch.CodeSearchWorker');
	worker.setScriptIncludeMethod('search');
	worker.putMethodArg('term', term);
	worker.putMethodArg('context', context);
	worker.setBackground(true);

	if (context?.scope) {
		worker.setSourceTable('sys_scope');
		worker.setSource(context.scope);
	}

	worker.start();

	return worker.getProgressID();
};
CodeSearchWorker.prototype = {
	initialize: function (trackerId) {
		this.api = new x_itx_codesearch.CodeSearchAPI();
		this.util = new x_itx_codesearch.Utilities();
		const limit = +gs.getProperty('sn_codesearch.search.results.max', '500');
		this.limit = isNaN(limit) ? 500 : this.limit;

		if (trackerId) {
			this.tracker = new GlideExecutionTracker(trackerId);
		} else {
			this.tracker = GlideExecutionTracker.getLastRunning();
		}

		this.tracker_id = this.tracker.getSysID();
	},

	search: function (term, context) {
		try {
			this._search(term, context);
		} catch (e) {
			gs.error(e.message + '\n' + global.NiceError._makeStackTraceFriendly(e.stack));
			this._fail('Failed: ' + e);
		}
	},

	/**
	 * searches for a term for a given scope and search group.
	 * 
	 * @param {string} term
	 * @param {object} [context]
	 * @param {string} [context.table]
	 * @param {string} [context.scope]
	 * @param {string} [context.group]
	 */
	_search: function (term, context) {
		let numAllHits = 0;

		const lastSearchGr = (() => {
			const lastSearchGr = CodeSearchWorker.getLastSearch(term, context);
			if (lastSearchGr.isValidRecord()) return lastSearchGr;
		})();

		const tables = this.api.getSearchTables(context);
		for (let i = 0; i < tables.length && !this._isCancelled(); i++) {
			const table = tables[i];

			if (this.limit && numAllHits >= this.limit) {
				this._updateMessage(`Stopping search because limit reached`);
				break;
			}

			this._updateMessage(`Searching '${table}'`);

			const { result, message } = (() => {
				if (lastSearchGr) {
					if (!this.api.updatedSince(table, lastSearchGr.sys_created_on, context)) {
						const executionGr = new GlideRecord('sys_execution_tracker');
						executionGr.addQuery('parent', lastSearchGr.sys_id);
						executionGr.addQuery('name', 'Table: ' + table);
						executionGr.setLimit(1);
						executionGr.query();
						if (executionGr.next()) {
							return {
								result: JSON.parse(executionGr.result),
								message: executionGr.message.toString()
							};
						}

						// return empty results because the table hasn't been changed since the last search
						// (empty results are not stored as execution trackers)
						return {
							result: {
								hits: []
							}
						};
					}
				}

				const hits = this.api.search(table, term, {
					scope: context?.scope,
					limit: this.limit ? Math.min(this.limit - numAllHits, 0) : undefined
				});

				if (hits.length == 0) {
					return {
						result: {
							hits: []
						}
					};
				}

				const url = this.util.createTinyURL(`/${table}_list.do?sysparm_query=sys_idIN${hits.join(',')}`);
				return {
					result: { table, term, hits },
					message: `<a target="_blank" href="${url}">results âžš</a> (${hits.length} hits)`
				};
			})();
				
			if (result.hits.length) {
				const child = this._createChild(`Table: ${table}`);
				child.run();
				child.updateResult(result); // needs to be a object!
				child.success(message);
				numAllHits += result.hits.length;
			}

			this._updatePercentComplete(Math.round((i / tables.length) * 100));
		}

		if (numAllHits >= this.limit) {
			// I was unable to change the parent success message - hardcoded to be "Success" ?
			const child = this._createChild(`Search Limit (${this.limit}) reached`);
			child.run();
			child.success();
		}

		this._success(`Found ${numAllHits} records in ${tables.length} tables`);
	},

	_createChild: function (name) {
		// not allowed in scoped application
		// return this.tracker.createChild(name);

		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_parent_tracker_id: this.worker_id,
			sysparm_child_name: name
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		return globalTracker._getTracker(globalTracker.createChild());
	},

	_updateMessage: function (message) {
		// not allowed in scoped application
		// this.tracker.updateMessage(message);

		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.tracker_id,
			sysparm_message: message
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.updateMessage();
	},
	
	_isCancelled: function () {
		const state = {
			PENDING: 0,
			RUNNING: 1,
			SUCCESSFULL: 2,
			FAILED: 3,
			CANCELLED: 4
		};
		
		const trackerGr = new GlideRecord('sys_execution_tracker');
		trackerGr.addQuery('sys_id', this.worker_id);
		trackerGr.addQuery('state', state.CANCELLED);
		trackerGr.setLimit(1);
		trackerGr.query();
		return trackerGr.hasNext();
	},
	
	_updatePercentComplete: function (percentage) {
		// not allowed in scoped application
		// this.tracker.updatePercentComplete(percentage);

		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.tracker_id,
			sysparm_percent_complete: percentage
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.updatePercentComplete();
	},

	_incrementPercentComplete: function () {
		// not allowed in scoped application
		// this.tracker.incrementPercentComplete(1);

		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.tracker_id
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.incrementPercentComplete();
	},
	
	_success: function (message, result) {	
		this._updateResult(result);
		this.tracker.success(message);
		
		// const globalTracker = new global.AJAXExecutionTracker();
		// const objs = {
		// 	sysparm_tracker_id: this.worker_id,
		// 	sysparm_message: message
		// };
		// globalTracker.getParameter = function (n) { return objs[n]; };
		// globalTracker.success();
	},

	_fail: function (message, result) {
		this._updateResult(result);
		this.tracker.fail(message);
		
		// const globalTracker = new global.AJAXExecutionTracker();
		// const objs = {
		// 	sysparm_tracker_id: this.worker_id,
		// 	sysparm_message: message
		// };
		// globalTracker.getParameter = function (n) { return objs[n]; };
		// globalTracker.fail();
	},

	_updateResult: function (result) {
		if (result) {
			this.tracker.updateResult(result);

			// const globalTracker = new global.AJAXExecutionTracker();
			// const tracker = globalTracker._getTracker(this.worker_id);
			// tracker.updateResult(result);
		}
	},

	type: 'CodeSearchWorker'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus@intrux.ch</sys_created_by>
        <sys_created_on>2025-11-28 17:55:52</sys_created_on>
        <sys_id>8f7528f4c3a9be90de14d8477d0131e0</sys_id>
        <sys_mod_count>97</sys_mod_count>
        <sys_name>CodeSearchWorker</sys_name>
        <sys_package display_value="Intrux Code Search" source="x_itx_codesearch">389ff177c355f290de14d8477d013127</sys_package>
        <sys_policy/>
        <sys_scope display_value="Intrux Code Search">389ff177c355f290de14d8477d013127</sys_scope>
        <sys_update_name>sys_script_include_8f7528f4c3a9be90de14d8477d0131e0</sys_update_name>
        <sys_updated_by>markus.kraus@intrux.ch</sys_updated_by>
        <sys_updated_on>2026-01-01 09:27:53</sys_updated_on>
    </sys_script_include>
</record_update>
