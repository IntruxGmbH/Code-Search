<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_itx_codesearch.CodeSearchWorker</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>CodeSearchWorker</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/* global global, gs, x_itx_codesearch */
/* global Set */
/* global Class, GlideRecord, GlideTableHierarchy, GlideScriptedHierarchicalWorker, GlideExecutionTracker */
/* eslint no-undef: "error" */
var CodeSearchWorker = Class.create();
CodeSearchWorker.start = function (term, context) {
	const worker = new GlideScriptedHierarchicalWorker();
	worker.setProgressName('Intrux Code Search: ' + term);
	worker.setScriptIncludeName('x_itx_codesearch.CodeSearchWorker');
	worker.setScriptIncludeMethod('search');
	worker.putMethodArg('term', term);
	worker.putMethodArg('context', context);
	worker.setBackground(true);

	if (context?.scope) {
		worker.setSourceTable('sys_scope');
		worker.setSource(context.scope);
	}

	worker.start();

	return worker.getProgressID();
};
CodeSearchWorker.prototype = {
	initialize: function (trackerId) {
		this.api = new x_itx_codesearch.CodeSearchAPI();
		this.util = new x_itx_codesearch.Utilities();
		const limit = +gs.getProperty('sn_codesearch.search.results.max', '500');
		this.limit = isNaN(limit) ? 500 : this.limit;

		if (trackerId) {
			this.tracker = new GlideExecutionTracker(trackerId);
		} else {
			this.tracker = GlideExecutionTracker.getLastRunning();
		}

		this.tracker_id = this.tracker.getSysID();
	},

	search: function (term, context) {
		try {
			this._search(term, context);
		} catch (e) {
			this._fail('Failed: ' + e);
			gs.error(e.message + '\n' + global.NiceError._makeStackTraceFriendly(e));
		}
	},

	/**
	 * searches for a term for a given scope and search group.
	 * 
	 * @param {string} term
	 * @param {object} [context]
	 * @param {string} [context.table]
	 * @param {string} [context.scope]
	 * @param {string} [context.group]
	 */
	_search: function (term, context) {
		let numAllHits = 0;
		const tables = this.api.getSearchTables(context);
		for (let i = 0; i < tables.length && !this._isCancelled(); i++) {
			const table = tables[i];

			if (this.limit && numAllHits >= this.limit) {
				this._updateMessage(`Stopping search because limit reached`);
				break;
			}

			this._updateMessage(`Searching '${table}'`);
			const result = {
				table: table,
				term: term,
				hits: this.api.search(table, term, {
					scope: context?.scope,
					limit: this.limit ? Math.min(this.limit - numAllHits, 0) : undefined
				})
			};
			
			if (result.hits.length) {
				const child = this._createChild(`Table: ${table}`);
				child.run();
				child.updateResult(result);
				const url = this.util.createTinyURL(`/${table}_list.do?sysparm_query=sys_idIN${result.hits.join(',')}`);
				child.success(`<a target="_blank" href="${url}">results âžš</a> (${result.hits.length} hits)`);
				numAllHits += result.hits.length;
			}

			this._updatePercentComplete(Math.round((i / tables.length) * 100));
		}

		if (numAllHits >= this.limit) {
			// I was unable to change the parent success message - hardcoded to be "Success" ?
			const child = this._createChild(`Search Limit (${this.limit}) reached`);
			child.run();
			child.success();
		}

		this._success(`Found ${numAllHits} records in ${tables.length} tables`);
	},

	_createChild: function (name) {
		// not allowed in scoped application
		// return this.tracker.createChild(name);

		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_parent_tracker_id: this.worker_id,
			sysparm_child_name: name
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		return globalTracker._getTracker(globalTracker.createChild());
	},

	_updateMessage: function (message) {
		// not allowed in scoped application
		// this.tracker.updateMessage(message);

		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.tracker_id,
			sysparm_message: message
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.updateMessage();
	},
	
	_isCancelled: function () {
		const state = {
			PENDING: 0,
			RUNNING: 1,
			SUCCESSFULL: 2,
			FAILED: 3,
			CANCELLED: 4
		};
		
		const trackerGr = new GlideRecord('sys_execution_tracker');
		trackerGr.addQuery('sys_id', this.worker_id);
		trackerGr.addQuery('state', state.CANCELLED);
		trackerGr.setLimit(1);
		trackerGr.query();
		return trackerGr.hasNext();
	},
	
	_updatePercentComplete: function (percentage) {
		// not allowed in scoped application
		// this.tracker.updatePercentComplete(percentage);

		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.tracker_id,
			sysparm_percent_complete: percentage
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.updatePercentComplete();
	},

	_incrementPercentComplete: function () {
		// not allowed in scoped application
		// this.tracker.incrementPercentComplete(1);

		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.tracker_id
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.incrementPercentComplete();
	},
	
	_success: function (message, result) {	
		this._updateResult(result);
		this.tracker.success(message);
		
		// const globalTracker = new global.AJAXExecutionTracker();
		// const objs = {
		// 	sysparm_tracker_id: this.worker_id,
		// 	sysparm_message: message
		// };
		// globalTracker.getParameter = function (n) { return objs[n]; };
		// globalTracker.success();
	},

	_fail: function (message, result) {
		this._updateResult(result);
		this.tracker.fail(message);
		
		// const globalTracker = new global.AJAXExecutionTracker();
		// const objs = {
		// 	sysparm_tracker_id: this.worker_id,
		// 	sysparm_message: message
		// };
		// globalTracker.getParameter = function (n) { return objs[n]; };
		// globalTracker.fail();
	},

	_updateResult: function (result) {
		if (result) {
			this.tracker.updateResult(result);

			// const globalTracker = new global.AJAXExecutionTracker();
			// const tracker = globalTracker._getTracker(this.worker_id);
			// tracker.updateResult(result);
		}
	},

	type: 'CodeSearchWorker'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus@intrux.ch</sys_created_by>
        <sys_created_on>2025-11-28 17:55:52</sys_created_on>
        <sys_id>8f7528f4c3a9be90de14d8477d0131e0</sys_id>
        <sys_mod_count>87</sys_mod_count>
        <sys_name>CodeSearchWorker</sys_name>
        <sys_package display_value="Intrux Code Search" source="x_itx_codesearch">389ff177c355f290de14d8477d013127</sys_package>
        <sys_policy/>
        <sys_scope display_value="Intrux Code Search">389ff177c355f290de14d8477d013127</sys_scope>
        <sys_update_name>sys_script_include_8f7528f4c3a9be90de14d8477d0131e0</sys_update_name>
        <sys_updated_by>markus.kraus@intrux.ch</sys_updated_by>
        <sys_updated_on>2025-12-30 18:06:16</sys_updated_on>
    </sys_script_include>
</record_update>
