<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_itx_codesearch.CodeSearchAPI</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>CodeSearchAPI</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/* global gs */
/* global Class, GlideScriptedExtensionPoint, GlideRecord, GlideTableHierarchy */
/* eslint no-undef: "error" */
var CodeSearchAPI = Class.create();
CodeSearchAPI.prototype = {
	initialize: function () {
		this.ext = new GlideScriptedExtensionPoint().getExtensions('CodeSearchExt')[0];
		this.ext.initialize();
	},

	getTableFields: function (table) {
		const dictionaryGr = new GlideRecord('sys_dictionary');
		dictionaryGr.addQuery('name', 'IN', new GlideTableHierarchy(table).getTables());
		dictionaryGr.addQuery('internal_type.scalar_type', 'string');
		dictionaryGr.addQuery('element', '!=', 'sys_id');
		dictionaryGr.addNotNullQuery('element');
		dictionaryGr.query();

		const fields = [{
			name: 'sys_id',
			type: 'GUID'
		}];
		while (dictionaryGr.next()) {
			fields.push({
				name: dictionaryGr.getValue('element'),
				type: dictionaryGr.getValue('internal_type')
			});
		}

		return fields;
	},

	/**
	 * @param {string} searchGroupName
	 * @returns {string[]}
	 */
	getSearchedTables: function (searchGroupName) {
		const searchedTables = [];
		const tableGr = new GlideRecord('sn_codesearch_table');
		tableGr.addQuery('search_group.name', searchGroupName);
		tableGr.query();
		while (tableGr.next()) {
			searchedTables.push(tableGr.table.toString());
		}

		return searchedTables;
	},

	/**
	 * @param {GlideRecordGenerated & sys_metadata} metadataGr
	 * @returns {object}
	 */
	metadataToData: function (metadataGr) {
		const data = {
			'class': metadataGr.getRecordClassName(),
			sys_id: metadataGr.getUniqueValue()
		};

		const record = metadataGr.getElement('ref_' + data['class']);
		if (record) {
			const recordGr = record.getRefRecord();
			if (recordGr && recordGr.isValidRecord()) {
				data.fields = this._getFields(recordGr);
			}
		}

		return data;
	},

	/**
	 * @param {GlideRecordGenerated} anyGr
	 * @returns {{ name: string, value: string }[]}
	 */
	_getFields: function (anyGr) {
		const fields = [];
		anyGr.getElements().forEach((element) => {
			const ge = element.getED();
			const type = ge.getInternalType();
			// gziped fields typically have this length (and usually there is only a single such field)
			if (type == 'string' && ge.getLength() == 16777215) {
				fields.push({
					name: element.getName(),
					value: this._deflateFields(element.toString())
				});
			} else if (type == 'glide_var' || type == 'variables') {
				fields.push({
					name: element.getName(),
					value: this._glideVarFields(element)
				});
			} else {
				fields.push({
					name: element.getName(),
					value: element.toString()
				});
			}
		});

		return fields;
	},

	/**
	 * @param {string} value
	 * @returns {{ name: string, value: string }[]}
	 */
	_deflateFields: function (value) {
		if (value) {
			const fields = JSON.parse(this.ext.inflate(value));
			if (Array.isArray(fields)) {
				return fields.map(field => {
					return {
						name: field.name,
						value: field.value,
						scriptActive: field.scriptActive,
						scripts: field.script
					};
				});
			}

			// simple Object.<string, string>
			return Object.entries(fields).map(([name, value]) => { return { name, value }; });
		}

		return [];
	},

	/**
	 * @param {GlideElementGenerated} glideElement
	 * @returns {{ name: string, value: string }[]}
	 */
	_glideVarFields: function (glideElement) {
		const values = [];
		for (const name in glideElement) {
			if (name == 'sys_id' || name == 'sys_meta') continue;

			values.push({
				name: name,
				value: String(glideElement[name])
			});
		}

		return values;
	},

	type: 'CodeSearchAPI'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus@intrux.ch</sys_created_by>
        <sys_created_on>2025-11-25 21:48:48</sys_created_on>
        <sys_id>fb560ebfc395f290de14d8477d013175</sys_id>
        <sys_mod_count>5</sys_mod_count>
        <sys_name>CodeSearchAPI</sys_name>
        <sys_package display_value="Intrux Code Search" source="x_itx_codesearch">389ff177c355f290de14d8477d013127</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Intrux Code Search">389ff177c355f290de14d8477d013127</sys_scope>
        <sys_update_name>sys_script_include_fb560ebfc395f290de14d8477d013175</sys_update_name>
        <sys_updated_by>markus.kraus@intrux.ch</sys_updated_by>
        <sys_updated_on>2025-11-25 23:13:32</sys_updated_on>
    </sys_script_include>
</record_update>
